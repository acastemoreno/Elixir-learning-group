<!DOCTYPE html>
<html>
<head>
<title></title>
<!-- 2017-10-28 sáb 16:10 -->
<meta  charset="utf-8" />
<meta  htto-equiv="X-UA-Compatible" content="chrome=1" />
<meta  name="generator" content="Org-mode with org-ioslide" />
<meta  name="author" content="Albert Castellano Moreno" />


<!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
<!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
<!--This one seems to work all the time, but really small on ipad-->
<!--<meta name="viewport" content="initial-scale=0.4">-->
<meta name="apple-mobile-web-app-capable" content="yes" />
<link rel="stylesheet" media="all" href="theme/css/default.css" />
<link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css" />
<link rel="stylesheet" media="all" href="theme/css/small-icon.css" />
<base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
<script data-main="js/slides" src="js/require-1.0.8.min.js"></script>

   <script src="js/jquery-1.7.1.min.js" type="text/javascript"></script>

<script src="js/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML,local/local" type="text/javascript"></script>
</head>
<body style="opacity: 0">
<slides class="layout-widescreen">
<slide class="title-slide segue nobackground">
       <aside class="gdbar"><img src="images/elixir.png"></aside>
       <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
       <hgroup class="auto-fadein">
         <h1 data-config-title><!-- populated from slide_config.json --></h1>
         <h2 data-config-subtitle><!-- populated from slide_config.json --></h2>
         <p data-config-presenter><!-- populated from slide_config.json --></p>
       </hgroup>
    </slide>
  
<slide id="sec-" class=" segue dark quote nobackground" style="background-image: url(nil)">
<aside class="gdbar right bottom"><img src="images/elixir.png"></aside><hgroup class="">
       <h2 class=" "><div id="outline-container-orgbb6bbe8" class="outline-2">
<h2 id="orgbb6bbe8">Funciones anonimas</h2>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="flexbox vleft auto-fadein" id="text-">


</article>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgf334696" class="outline-3">
<h3 id="orgf334696">Creando funciones anonimas</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Las funciones anonimas tienen la siguiente forma: <code>fn(&lt;parametro1&gt;, &lt;parametro2&gt;, ....) -&gt; &lt;ejecucion y retorno&gt; end</code>
</p>

<p>
Crearemos funciones en IEx y las guardaremos en una variable para posteriormente utilizarlas:
</p>

<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; velocidad = fn (distancia) -&gt; :math.sqrt(2 * 9.81 * distancia) end
#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;
## El retorno nos sirve para corroborrar que hemos creado una funcion y
## no resulto en error.
iex&gt; sum = fn (a, b) -&gt; a + b end
#Function&lt;12.17052888 in :erl_eval.expr/5&gt;
iex&gt; sum.(1, 2)
3</pre>

</div>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org36b2955" class="outline-3">
<h3 id="org36b2955">Funciones anonimas creadas en multiples Lineas</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Ahora podemos separar en piezas nuestras funciones dentro de multiples lineas, esto hace que sea más legible. IEx mantiene la linea abierta hasta que tipees <code>end</code>. El ejemplo anterior de esta manera:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
##En este caso obviamos englobar en parentesis
##los parametros porque solo existe uno solo.
iex&gt; velocidad = fn
...&gt; distancia -&gt; :math.sqrt(2 * 9.81 * distancia)
...&gt; end
#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;
iex&gt; velocidad.(10)
14.007141035914502</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org9631e82" class="outline-3">
<h3 id="org9631e82">Funciones Anonimas y Pattern Matching</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Cada vez que evaluamos una funcion anonima, un patron se matchea con la data suministrada, de lo cual deriva en asignaciones, para que luego sean utilizadas. Esto significa que se puede hacer matcheos de mayor complejidad
Ejemplos:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
##En este caso se esta pasando un solo parametro que es una tupla y se esta devolviendo otra tupla con el orden invertido.
iex&gt; intercambio = fn
...&gt; {primero, segundo} -&gt; {segundo, primero}
...&gt; end
#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;
iex&gt; intercambio.({6, 8})
{8, 6}</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgf6e4c1e" class="outline-3">
<h3 id="orgf6e4c1e">Una funcion anonima, multiples cuerpos</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Para el siguiente ejemplo, en mi carpeta creo un archivo <code>holiwoli.txt</code> que no es necesario que tenga contenido.
</p>

<article class="flexbox vcenter">

<div class="figure">
<p><img src="images/holiwoli.png" alt="holiwoli.png" width="450px" />
</p>
</div>
</article>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org2689e34" class="outline-3">
<h3 id="org2689e34"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Ejecuto <code>iex</code> en la carpeta donde se ubica <code>holiwoli.txt</code> y ejecuto lo siguiente. Analizamos el uso de una funcion llamada <code>open</code>, dentro de la libreria <code>File</code>, que por defecto Elixir ya incorpora.
</p>
<article class="flexbox vcenter">

<div class="figure">
<p><img src="images/file_open.png" alt="file_open.png" width="500px" />
</p>
</div>
</article>
<p>
Al ejecutar la funcion, esta retorna una tupla, tal que su primer elemento es un atomo que representa el exito o fracaso de la operación, y el segundo es segun el primer termino, un identificador unico de proceso ó un mensaje de error.
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgdfa1c6c" class="outline-3">
<h3 id="orgdfa1c6c"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Ahora creamos una funcion anonima que procese ese resultado y dependiendo del caso realiza una accion u otra.
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; verificar_archivo = fn
...&gt; {:ok, archivo} -&gt; "Leyendo archivo: #{IO.read(archivo, :line)}"
...&gt; {_, error}  -&gt; "Error: #{:file.format_error(error)}"
...&gt; end
#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org6368a48" class="outline-3">
<h3 id="org6368a48"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="smaller" id="text-">
<article class="flexbox vcenter">

<div class="figure">
<p><img src="images/verificar_archivo.png" alt="verificar_archivo.png" width="850px" />
</p>
</div>
</article>
<p>
Lo que hace la función es verificar el primer primer patron que en este caso es <code>{:ok, archivo}</code>. Si consigue hacer el match <code>{:ok, archivo} = File.open(".......")</code> imprime el texto <code>Leyendo archivo: ........</code>, y si no matchea intentara hacer un nuevo match con <code>{_, error}</code> de la siguiente forma <code>{_, error} = File.open(".......")</code>, si logra hacer este ultimo match se imprimira el texto <code>Error: ..........</code>
</p>

<p>
Significa que importa el orden de las <code>definiciones</code>.
</p>


</article>

</slide>

</slide>

</slide>
<slide id="sec-" class=" segue dark quote nobackground" style="background-image: url(nil)">
<aside class="gdbar right bottom"><img src="images/elixir.png"></aside><hgroup class="">
       <h2 class=" "><div id="outline-container-orgdffcf3c" class="outline-2">
<h2 id="orgdffcf3c">Shortcut &amp;</h2>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="flexbox vleft auto-fadein" id="text-">


</article>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org8bc8b65" class="outline-3">
<h3 id="org8bc8b65"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="smaller" id="text-">
<p>
Hemos observador hasta el momento que para crear una funcion anonima es necesario definir 2 partes importantes:
</p>
<ul>
<li>El patron</li>
<li>El contenido que ejecuta</li>
</ul>
<p>
Ahora, existe algo más practico que toma en concideracion el orden de los parametros que se estan tomando. Eso más practico es el uso de <code>&amp;</code> para definir funciones anonimas.
</p>

<p>
Aqui un ejemplo en la forma como se utilizan.
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; doble = &amp;(&amp;1 * 2)
#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;
iex&gt; doble.(7)
14</pre>

</div>
<p>
<code>&amp;(...)</code> se refiere a la creacion de una funcion anonima. <code>&amp;1</code> representa el primer parametro  obtenido al evaluar la funcion. Entonces <code>&amp;(&amp;1 * 2)</code> es una funcion anonima de aridad 1 que toma su primer parametro (primer y unico parametro) y devuelve el doble.
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org0dfd4da" class="outline-3">
<h3 id="org0dfd4da"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
<code>&amp;(....)</code> tiene las siguientes variaciones:
</p>
<ul>
<li><code>&amp;{....}</code>: Funcion anonima que crea una tupla como resultado</li>
<li><code>&amp;[....]</code>: Funcion anonima que crea una lista como resultado</li>
</ul>
<p>
Ejemplos:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; cociente_residuo = &amp;{ div(&amp;1,&amp;2), rem(&amp;1,&amp;2) }
#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;
iex&gt; cociente_residuo.(13, 5)
{2, 3}
iex&gt; lista = &amp;[&amp;1, &amp;1 * 2, &amp;1 * 3]
#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;
iex&gt; lista.(5)
[5, 10, 15]</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgc8499ab" class="outline-3">
<h3 id="orgc8499ab">Usos de &amp;</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Sabemos que hace <code>&amp;(....)</code>, pero para que sirve?
</p>

<p>
Sirve crear funciones anonimas como parametros de otras funciones:
</p>

<p>
Ejemplos:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; Enum.map [1,2,3,4], &amp;(&amp;1 + 1)
[2, 3, 4, 5]
iex&gt; Enum.map [1,2,3,4], &amp;(&amp;1 * &amp;1)
[1, 4, 9, 16]
iex&gt; Enum.map [1,2,3,4], &amp;(&amp;1 &lt; 3)
[true, true, false, false]
iex&gt; Enum.filter [1,2,3,4], &amp;(&amp;1 &lt;= 3)</pre>

</div>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgf47007e" class="outline-3">
<h3 id="orgf47007e">Ejercicios</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Crear funciones anonimas en sus 2 formas (fn, &amp;, eso si esto es posible) que den estos resultados:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; saludo.(%{nombre:"Albert", edad: 25})
"Hola Albert, tienes 25 años"
iex&gt; proceso.(1..40)
[1,4,9,16,25] # Elementos al cuadrado y luego filtrados (solo menores iguales a 30)</pre>

</div>


</article>

</slide>

</slide>

</slide>
<slide id="sec-" class=" segue dark quote nobackground" style="background-image: url(nil)">
<aside class="gdbar right bottom"><img src="images/elixir.png"></aside><hgroup class="">
       <h2 class=" "><div id="outline-container-orgc86b2bb" class="outline-2">
<h2 id="orgc86b2bb">Modulos</h2>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="flexbox vleft auto-fadein" id="text-">


</article>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org4e25792" class="outline-3">
<h3 id="org4e25792">Qué es un Modulo?</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Una vez que tu codigo crece, es una necesidad real estructuralo. Partes tu codigo en funciones con nombre y los organizas dentro de modulos.
</p>

<p>
Los modulos te dan la habilidad de guardar, encapsular, compartir y manejar tu codigo de la manera más eficiente.
</p>

<p>
Cada modulo tiene extension <code>.ex</code> ó <code>.exs</code> (<code>.ex</code> es para archivos que sera compilados y <code>.exs</code> son para crear scripts ó mejor dicho archivos que se interpretan en beam pero que no es necesario que se compilen).
</p>

<p>
Nota: Nombres de Archivos que representen modulos respetan la regla del camello (CamelCase).
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org55d92bc" class="outline-3">
<h3 id="org55d92bc">Creando nuestro primer modulo</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="smaller" id="text-">
<p>
Creamos el archivo <code>caida.exs</code> dentro de nuestra carpeta y con el editor de texto escribimos lo siguiente:
</p>

<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
#Archivo: caida.exs
defmodule Caida do
  def velocidad(altura) do
    :math.sqrt(2 * 9.81 * altura)
  end
end</pre>

</div>
<p>
En el codigo escrito podemos ver que existe un modulo <code>Caida</code>, tal que engloba entre <code>do ...... end</code> a una funcion con nombre <code>velocidad</code>. Esta funcion <code>velocidad</code>, recibe un parametro <code>altura</code>, que al ser evaluada se matchea para luego ejecutarse el contenido entre <code>do ... end</code> que es <code>:math.sqrt(2 * 9.81 * altura)</code>
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org48d4317" class="outline-3">
<h3 id="org48d4317">Cargando nuestro codigo en consola</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="smaller" id="text-">
<p>
Existen 2 formas de usar el codigo en archivos.
</p>
<ul>
<li>Ejecutando <code>iex &lt;nombre de archivo&gt;</code> para luego ejecutarlo</li>
</ul>
<div class="org-src-container">

<pre class="prettyprint" data-lang="cmd">
$ iex caida.exs
iex&gt; Caida.velocidad(100)
44.294469180700204</pre>

</div>
<ul>
<li>Estando en iex, ejecutamos <code>c &lt;"nombre de archivo"&gt;</code></li>
</ul>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; c "caida.exs"
[Caida]
iex&gt; Caida.velocidad(100)
44.294469180700204</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org3e1e5c3" class="outline-3">
<h3 id="org3e1e5c3">Patten Matching en funciones con nombre</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
En funciones anonimas teniamos la posibilidad de crear multiples cuerpos ó por decirlo de otra forma, que la funcion responda segun los parametros de entrada.
</p>

<p>
Lo mismo tenemos en funciones con nombres.
</p>

<p>
Ejemplo:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
#factorial.exs
defmodule Factorial do
  def de(0), do: 1
  def de(n), do: n * de(n-1)
end</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org0a5126c" class="outline-3">
<h3 id="org0a5126c"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
#factorial.exs
defmodule Factorial do
  def de(0), do: 1
  def de(n), do: n * de(n-1)
end</pre>

</div>
<p>
Cuando el parametro es 0, el resultado es 1.
</p>

<p>
Cuando el parametro no es 0, almacenamos el parametro de entrada en la variable <code>n</code> y luego evaluamos <code>n</code> por el factorial de <code>n</code> menos 1.
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org006d695" class="outline-3">
<h3 id="org006d695"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
#factorial1.exs
iex&gt; c "factorial.exs"
[Factorial]
iex&gt; Factorial.de(3)
6
iex&gt; Factorial.de(7)
5040
iex&gt; Factorial.de(10)
3628800</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgca294cb" class="outline-3">
<h3 id="orgca294cb">Otro ejemplo</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
#fibo.exs
defmodule Fibonacci do
  def de(0), do: 0

  def de(1), do: 1

  def de(n) do
    de(n-1) + de(n-2)
  end
end</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgdcb4b16" class="outline-3">
<h3 id="orgdcb4b16">Guard Clauses</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="smaller" id="text-">
<p>
<code>when</code> nos ayuda a verificar los tipos de las variables que hacen match.
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
#lista_numero.exs
defmodule ListaNumero do
  def que_es(x) when is_number(x) do
    "#{x} es un numero"
  end
  def que_es(x) when is_list(x) do
    "#{inspect(x)} es una lista"
  end
end</pre>

</div>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; c "lista_numero.exs"
[ListaNumero]
iex&gt; ListaNumero.que_es(5)
"5 es un numero"
iex&gt; ListaNumero.que_es([5])
"[5] es una lista"</pre>

</div>
<p>
LIMITACIONES: Solo estan permitidas estas <a href="https://hexdocs.pm/elixir/guards.html#content">Guardias</a> dentro de <code>when</code>. <a href="https://hexdocs.pm/elixir/guards.html#defining-custom-guard-expressions">O quizas no exista limitación</a>.
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgdfd94e6" class="outline-3">
<h3 id="orgdfd94e6">Ejercicio</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; fizzbuzz(15) #Multiplo de 5 y 3
"Fizzbuzz"
iex&gt; fizzbuzz(6) #Multiplo de 3
"Fizz"
iex&gt; fizzbuzz(10) #MUltiplo de 5
"Buzz"
iex&gt; fizbuzz("Holi")
"Qué paso amiguito?"</pre>

</div>


</article>

</slide>

</slide>

</slide>
<slide id="sec-" class=" segue dark quote nobackground" style="background-image: url(nil)">
<aside class="gdbar right bottom"><img src="images/elixir.png"></aside><hgroup class="">
       <h2 class=" "><div id="outline-container-org2ea529b" class="outline-2">
<h2 id="org2ea529b">The amazing Pipe Operator</h2>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="flexbox vleft auto-fadein" id="text-">


</article>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org57ee2d0" class="outline-3">
<h3 id="org57ee2d0">Pipe Operator |&gt;</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Que pasa si queremos elevar al cuadrado los elementos de una lista para luego filtrar a los que sean menores a 40. Tendriamos que usar la siguiente funcion:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; lista = 1..10
1..10
iex&gt; cuadrado = Enum.map(lista, &amp;(&amp;1 * &amp;1))
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
iex&gt; filtrado = Enum.filter(cuadrado, &amp;(&amp;1 &lt; 40))
[1, 4, 9, 16, 25, 36]</pre>

</div>
<p>
Entendemos este codigo, pero almacenamos muchas variables temporales (codigo poco eficiente).
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orge97238b" class="outline-3">
<h3 id="orge97238b">Pipe Operator |&gt;</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Ahora, si no queremos almacenar variables temporales podemos hacer lo siguiente:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; filtrado = Enum.filter(Enum.map(1..10, &amp;(&amp;1 * &amp;1)), &amp;(&amp;1 &lt; 40))
[1, 4, 9, 16, 25, 36]
## Lo siento, por hacerles ver algo tan feo.</pre>

</div>
<p>
Funciona, pero es dificil de leer y escalar, facilmente puede ocasionar errores. No es elegante.
</p>


</article>

</slide>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org2f7f6d9" class="outline-2">
<h2 id="org2f7f6d9"></h2>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Muchos lenguajes nos obligan a tomar una decision sobre cual usar. Ser poco productivo pero hacer codigo eficiente ó ser productivo pero tu codigo es ineficiente.
calma.jpg
</p>
<article class="flexbox vcenter">

<div class="figure">
<p><img src="images/calma.jpg" alt="calma.jpg" width="600px" />
</p>
</div>
</article>


</article>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgd004dd1" class="outline-3">
<h3 id="orgd004dd1"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Siganme los buenos.
</p>

<p>
Una solucion elegante es pensar en funciones como transformaciones de información. Tal que el primer parametro de una funcion es el elemento a transformar, y los demas parametros son configuraciones a la transformación que se da.
</p>

<p>
Resumiendo en una sola linea. En ves de usar f(val,a,b), usamos val |&gt; f(a,b). 
</p>

<p>
Aplicando a nuestro ejemplo.
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; resultado = 1..10 |&gt; Enum.map(&amp;(&amp;1*&amp;1)) |&gt; Enum.filter(&amp;(&amp;1 &lt; 40))
[1, 4, 9, 16, 25, 36]</pre>

</div>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org973939c" class="outline-3">
<h3 id="org973939c"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<article class="flexbox vcenter">

<div class="figure">
<p><img src="images/mi_astucia.jpg" alt="mi_astucia.jpg" width="450px" />
</p>
</div>
</article>


</article>

</slide>

</slide>

</slide>
<slide id="sec-" class=" segue dark quote nobackground" style="background-image: url(nil)">
<aside class="gdbar right bottom"><img src="images/elixir.png"></aside><hgroup class="">
       <h2 class=" "><div id="outline-container-orgbfd7380" class="outline-2">
<h2 id="orgbfd7380">Recursión</h2>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="flexbox vleft auto-fadein" id="text-">


</article>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orga0dabdb" class="outline-3">
<h3 id="orga0dabdb">Implementación de Listas (Necesario tener claro como funcionan las listas)</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Las listas en Elixir pueden ser vacias ó pares inmutables <code>head/tail</code> 
</p>

<p>
donde el <code>head</code> contiene un valor y el <code>tail</code> es en si misma una lista
</p>

<p>
Ejemplos:
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; [ head | tail ] = [ 1, 2, 3 ] # =&gt; [1, 2, 3]
iex&gt; head 
1
iex&gt; tail 
[2, 3]</pre>

</div>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org497a755" class="outline-3">
<h3 id="org497a755">Prepending en listas es <code>Rapido</code></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; list1 = [1, 2, 3]
iex&gt; list2 = [0 | list1] </pre>

</div>
<article class="flexbox vcenter">

<div class="figure">
<p><img src="images/prepending.png" alt="prepending.png" width="700px" />
</p>
</div>
</article>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org8794b36" class="outline-3">
<h3 id="org8794b36">Appending en listas es <code>Lento</code></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; list1 = [1, 2, 3]
iex&gt; list2 = list1 ++ [4] </pre>

</div>
<article class="flexbox vcenter">

<div class="figure">
<p><img src="images/appending.png" alt="appending.png" width="700px" />
</p>
</div>
</article>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org6ab01b6" class="outline-3">
<h3 id="org6ab01b6">Insertar elementos es <code>Lento</code></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; list1 = [1, 3, 4]
iex&gt; list2 = List.insert_at(list1, 1, 2) # insertando 2 en la segunda posicion
iex&gt; [1, 2, 3, 4]</pre>

</div>
<article class="flexbox vcenter">

<div class="figure">
<p><img src="images/insert_list.png" alt="insert_list.png" width="700px" />
</p>
</div>
</article>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org9f7eb52" class="outline-3">
<h3 id="org9f7eb52">Implementación de Listas</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<ul>
<li>Elixir son pares head/tail</li>
<li>Inmutabilidad hacen que sean eficientes en memoria</li>
<li>Prepending es RAPIDO</li>
<li>Appending es LENTO</li>
<li>Insertando elementos puede ser lento</li>
<li>Leer la lista entera puede ser lento</li>
</ul>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org2595ff7" class="outline-3">
<h3 id="org2595ff7">Recursion</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<blockquote>
<p>
Recurrencia, recursión o recursividad es la forma en la cual se especifica un proceso basado en su propia definición.
<span class='float-right'>&#x2013; Wikipedia</span><br  />
</p>
</blockquote>
<blockquote>
<p>
De hecho, recursión es una de las ideas centrales de ciencia de computación.Resolver un problema mediante recursión significa que la solución depende de las soluciones de pequeñas instancias del mismo problema.
<span class='float-right'>&#x2013; Recursión (ciencias de computación) - Wikipedia</span><br  />
</p>
</blockquote>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org4041a81" class="outline-3">
<h3 id="org4041a81">Utilidad (Mediante ejemplo)</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
#suma.ex
defmodule Suma do
  def hasta(0), do: 0
  def hasta(n), do: n + hasta(n - 1)
end

iex&gt;Suma.hasta(10)
=10+hasta(9)
=10+(9+hasta(8))
=10+(9+(8+hasta(7)))
=10+(9+(8+(7+(6+(5+(4+(3+(2+(1+(0))))))))))</pre>

</div>
<p>
Puede causar algo llamado <b>Stackoverflow</b>
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org6619207" class="outline-3">
<h3 id="org6619207">Recordando ejemplo</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
#factorial.exs
defmodule Factorial do
  def de(0), do: 1
  def de(n), do: n * de(n-1)
end</pre>

</div>
<p>
Si calculamos el factorial de <code>1_000_000</code>. El consumo de memoria puede ocasionar el colapso total de nuestro sistema.
</p>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org69451e6" class="outline-3">
<h3 id="org69451e6">Arreglemos el factorial</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<p>
Para evitar stackoverflow, elixir nos aconseja que lo ultimo que hagamos en una función <b>recursiva</b> es ejecutar una función.
Pero en nuestro caso necesitamos que el factorial se llame a si mismo al final de su ejecución.
</p>
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
defmodule Factorial do
  def de(0), do: 1
  def de(n), do: de(n-1)
end
# Ahora necesitamos ir acumulando resultados parciales cada vez que n se reduzca
# (esto nos obliga a crear un nuevo parametro que sirva como acumulador)</pre>

</div>


</article>

</slide>
</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-org303fa17" class="outline-3">
<h3 id="org303fa17"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
defmodule Factorial do
  def de(0,acc), do: 1
  def de(n,acc), do: de(n-1,acc)
end</pre>

</div>

<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
# Agregamos la multiplicación  y al final de nuestro
defmodule Factorial do
  def de(0,acc), do: acc
  def de(n,acc), do: de(n-1, acc*n)
end
iex&gt; Factorial(1,1) #1
iex&gt; Factorial(2,1) #2</pre>

</div>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orge6f4ec8" class="outline-3">
<h3 id="orge6f4ec8"></h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
# cambiamos la funcion para que sea privada y sea utilizada por otra función
defmodule Factorial do
  def de(n), do: p_de(n,1)
  defp p_de(0, acc), do: acc
  defp p_de(n, acc), do: de(n-1, acc*n)
end</pre>

</div>


</article>

</slide>

</slide>
<slide id="sec-"  >
<hgroup class="">
       <h2 class=" "><div id="outline-container-orgf865ecc" class="outline-3">
<h3 id="orgf865ecc">Más ejemplos</h3>
</div>
</h2>
       <h3></h3>
       </hgroup>
<article class="" id="text-">
<div class="org-src-container">

<pre class="prettyprint" data-lang="elixir">
iex&gt; MiLista.suma([1,2,3,4,5,6])
21
iex&gt; MiLista.longitud([1,2,3,4])
4
iex&gt; MiLista.map([1,2,3,4,5], &amp;(&amp;1*&amp;1))
[1,4,9,16,25]
iex&gt; MiLista.fibonacci([1,1], 7)
[1,1,2,3,5,8,13]
iex&gt; MiLista.tribonacci([1,1,1], 7)
[1,1,1,3,5,9,17]</pre>

</div>


</article>

</slide>

</slide>

</slide>
<slide id="sec-" class=" thank-you-slide segue nobackground" style="background-image: url(nil)">
<aside class="gdbar right"><img src="images/elixir.png"></aside><article class="flexbox vleft auto-fadein" id="text-">
<h2>
  <p>Gracias ˊ・ω・ˋ</p>
</h2>
<br>
<p class="auto-fadein" data-config-contact>
</p>
</article>

</slide>
<slide class="backdrop"></slide>
</slides> 
<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body> 

</html>
